6. CSS选择符有哪些?

   > ```
   > id 选择器（#myid）
   > 类选择器（.myclassname）
   > 标签选择器（div,h1,p）
   > 后代选择器（h1 p）
   > 相邻后代选择器（子）选择器（ul>li）
   > 兄弟选择器（li~a）
   > 相邻兄弟选择器（li+a）
   > 属性选择器（a[rel="external"]）
   > 伪类选择器（a:hover,li:nth-child）
   > 伪元素选择器（::before、::after）
   > 通配符选择器（*）
   > ```

7. 如何处理HTML5新标签的浏览器兼容问题?

   > - (1) IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。
   > - (2)当然也可以直接使用成熟的框架，比如 html5shim `` [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。

8. CSS多列等高如何实现？

   > - 1.利用 padding-bottom|margin-bottom 正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定 padding-bottom 时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的 padding-bottom补偿这部分高度差。
   > - 2.利用 table-cell 所有单元格高度都相等的特性，来实现多列等高。
   > - 3.利用 flex 布局中项目 align-items 属性默认为 stretch，如果项目未设置高度或设为 auto，将占满整个容器的高度的特性，来实现多列等高。

9. margin和padding分别适合什么场景使用？

   > margin 是用来隔开元素与元素的间距；padding 是用来隔开元素与内容的间隔。 margin 用于布局分开元素使元素与元素互不相干。 padding 用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。
   >
   > 何时应当使用 margin
   >
   > ```
   > 需要在 border 外侧添加空白时。
   > 空白处不需要背景（色）时。
   > 上下相连的两个盒子之间的空白，需要相互抵消时。如 15px+20px 的 margin，将得到 20px的空白。
   > ```
   >
   > 何时应当时用 padding
   >
   > ```
   > 需要在 border 内测添加空白时。
   > 空白处需要背景（色）时。
   > 上下相连的两个盒子之间的空白，希望等于两者之和时。如 15px+20px 的 padding，将得到35px 的空白.
   > ```

10. 说一下html布局元素的分类有哪些?以描述下每种布局元素的应用场景么?

    > ## 分类
    >
    > - 内联元素 `span a b strong i em br input textarea` 本身属性为`display:inline`
    >
    > 和其他行内元素从左到右在一行显示，不可以直接控制宽度、高度等其他相关的css属性，但是可以直接设置内外边距的左右值
    >
    > 宽高是由本身内容大小决定的(文字、图片等)
    >
    > 只能容纳文本或者其他行内元素，不能嵌套块级元素
    >
    > - 块级元素
    >
    > ```
    > div h1-h6 hr menu ol ul li table from` 本身属性为`display:block
    > ```
    >
    > 独占一行，每一个块级元素都会从新的一行重新开始，从上到下排布，可以直接控制宽度、高度等其他相关css属性
    >
    > 在不设置宽度的情况下，块级元素的宽度是它父级元素内容的宽度
    >
    > 在不设置高度的情况下，块级元素的高度是它本身内容的高度
    >
    > - 内联块状元素
    >
    > 内联块状元素综合以上两种的特性又有所不同
    >
    > 不能自动换行
    >
    > 能够识别width height line-height padding margin默认排列方式为从左到右
    >
    > ## 应用场景
    >
    > - 内联元素：用于不指定宽高，宽高由内容指定
    > - 块状元素：用于指定宽高，标签占满一行
    > - 内联块装元素：用于指定元素宽高，不占满一行

11. 前端需要注意哪些SEO?

    > - (1)合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。
    > - (2)语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。
    > - (3)重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。
    > - (4)重要内容不要用 js 输出：爬虫不会执行 js 获取内容
    > - (5)少用 iframe：搜索引擎不会抓取 iframe 中的内容
    > - (6)非装饰性图片必须加 alt
    > - (7)提高网站速度：网站速度是搜索引擎排序的一个重要指标

12. display、position和float的相互关系?

    > - 首先我们判断 display 属性是否为 none，如果为 none，则 position 和 float 属性的值不影响元素最后的表现。
    >
    > - 然后判断 position 的值是否为 absolute 或者 fixed，如果是，则 float 属性失效，并且display 的值应该被设置为 table 或者 block，具体转换需要看初始转换值。
    >
    > - 如果 position 的值不为 absolute 或者 fixed，则判断 float 属性的值是否为 none，如果不是，则 display的值则按上面的规则转换。注意，如果 position 的值为 relative 并且 float 属性的值存在，则relative 相对于浮动后的最终位置定位。
    >
    > - 如果 float 的值为 none，则判断元素是否为根元素，如果是根元素则 display 属性按照上面的规则转换，如果不是，则保持指定的 display 属性值不变。
    >
    >   ```js
    >   总的来说，可以把它看作是一个类似优先级的机制，"position:absolute"和"position:fixed"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是"none"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。
    >   ```
    >
    >   

13. 说一下你理解margin重叠的问题.

    > > 块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为"margin合并"
    >
    > 产生折叠的必备条件：margin 必须是邻接的，而根据 w3c 规范，两个 margin 是邻接的必须满足以下条件：
    >
    > - 必须是处于常规文档流（非 float 和绝对定位）的块级盒子，并且处于同一个 BFC 当中。
    > - 没有线盒，没有空隙，没有 padding 和 border 将他们分隔开
    > - 都属于垂直方向上相邻的外边距，可以是下面任意一种情况
    > - 元素的 margin-top 与其第一个常规文档流的子元素的 margin-top
    > - 元素的 margin-bottom 与其下一个常规文档流的兄弟元素的 margin-top
    > - height 为 auto 的元素的 margin-bottom 与其最后一个常规文档流的子元素的 margin-bottom
    > - 高度为 0 并且最小高度也为 0，不包含常规文档流的子元素，并且自身没有建立新的 BFC的元素的 margin-top和 margin-bottom
    >
    > ## margin 合并的 3 种场景：
    >
    > - \1. 相邻兄弟元素 margin 合并。 解决办法：设置块状格式化上下文元素（BFC）
    > - \2. 父级和第一个/最后一个子元素的 margin 合并。 解决办法：对于 margin-top 合并，可以进行如下操作（满足一个条件即可）：
    >
    > ```
    > 父元素设置为块状格式化上下文元素；
    > 父元素设置 border-top 值；
    > 父元素设置 padding-top 值；
    > 父元素和第一个子元素之间添加内联元素进行分隔。
    > ```
    >
    > 对于 margin-bottom 合并，可以进行如下操作（满足一个条件即可）：
    >
    > ```
    > 父元素设置为块状格式化上下文元素；
    > 父元素设置 border-bottom 值；
    > 父元素设置 padding-bottom 值；
    > 父元素和最后一个子元素之间添加内联元素进行分隔；
    > 父元素设置 height、min-height 或 max-height。
    > ```
    >
    > - \3. 空块级元素的 margin 合并。 解决办法：
    >
    > ```
    > 设置垂直方向的 border；
    > 设置垂直方向的 padding；
    > 里面添加内联元素（直接 Space 键空格是没用的）；
    > 设置 height 或者 min-height。
    > 回答：
    > ```
    >
    > > margin 重叠指的是在垂直方向上，两个相邻元素的 margin 发生重叠的情况。 一般来说可以分为四种情形：
    >
    > ```
    > 第一种是相邻兄弟元素的 marin-bottom 和 margin-top 的值发生重叠。这种情况下我们可以通过设置其中一个元素为 BFC来解决。
    > 第二种是父元素的 margin-top 和子元素的 margin-top 发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置 border-top、padding-top 值来分隔它们，当然我们也可以将父元素设置为 BFC来解决。
    > 第三种是高度为 auto 的父元素的 margin-bottom 和子元素的 margin-bottom 发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置 border-bottom、padding-bottom 来分隔它们，也可以为父元素设置一个高度，max-height 和 min-height 也能解决这个问题。当然将父元素设置为BFC 是最简单的方法。
    > 第四种情况，是没有内容的元素，自身的 margin-top 和 margin-bottom 发生的重叠。我们可以通过为其设置 border、padding 或者高度来解决这个问题
    > ```

14. 简单介绍使用图片base64编码的优点和缺点.

    > > base64 编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url 属性。
    >
    > 使用 base64 的优点是：减少一个图片的 HTTP 请求 使用 base64 的缺点是：
    >
    > - 1.根据 base64 的编码原理，编码后的大小会比原文件大小大 1/3，如果把大图片编码到html/css 中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对 html 或 css 文件解析渲染的时间。
    > - 2.使用 base64 无法直接缓存，要缓存只能缓存包含 base64 的文件，比如 HTML 或者 CSS，这相比域直接缓存图片的效果要差很多。
    > - 3.兼容性的问题，ie8 以前的浏览器不支持。
    >
    > 一般一些网站的小图标可以使用`base64图片`来引入。

15. iframe有哪些缺点?

    > > frame 元素会创建包含另外一个文档的内联框架（即行内框架）。
    >
    > ```
    > 主要缺点有:
    > （1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。
    > （2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。
    > （3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的
    > 并行加载。
    > （4） 浏览器的后退按钮失效。
    > （5） 小型的移动设备无法完全显示框架。
    > ```

16. DOCTYPE 的作用是什么?

    > - IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。
    > - <!DOCTYPE>声明位于 HTML 文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。
    > - <!DOCTYPE> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。
    > - 在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。

17. link 标签定义

    > - link 标签定义文档与外部资源的关系。
    > - link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。
    > - link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet指的是定义一个外部加载的样式表。

18. 为什么不建议使用通配符初始化css样式?

    > 采用`*{pading:0;margin:0;}`这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。出于性能的考虑，并不是所有标签都会有 padding 和 margin，因此对常见的具有默认 padding和 margin 的元素初始化即可，并不需使用`通配符*`来初始化。

19. 什么情况下出现浏览器分层？(css部分)

    > ### 分层和合成
    >
    > 通常页面的组成是十分复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，以及还有一些比较炫酷的3D动画效果。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种"牵一发而动全身"的绘制策略会严重影响页面的渲染效率。
    >
    > 为了提升每帧的渲染效率，Chrome引入了分层和合成的机制
    >
    > 你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应着一个图层，Chrome合成器最终将这些图层合成了用于显示页面的图片。如果你比较熟悉PS的话，就很好的理解这个过程，PS中一个项目是由很多图层构成的，每个图层都可以是一张单独的图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了
    >
    > 在这个过程中，将素材分解为多个图层操作的就称之为分层，最后将这些图层合并在一起的操作就称为合成。所以，分成和合成通常是一起使用的
    >
    > 考虑一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者渐变，这个时候合成器只需要将两个层进行相应的变化操作就可以，显卡处理这些操作驾轻就熟，所以合成时间非常短
    >
    > ### 生成层的方式
    >
    > 在某些特定的条件下，浏览器会主动将渲染层提至合成层，那么影响这个合成因素有哪些？
    >
    > - 3D transforms:translate3d,translateZ等
    > - video,canvas,iframe等
    > - 通过Element.animate()实现的opacity动画转化
    > - 通过CSS动画实现的opacity动画转换
    > - position:fixed
    > - will-change
    > - filter
    > - 有合成层后代同时本身overflow不为visible(如果本身是因为明确的定位因素产生的SelfPaintingLayer,则需要z-index不为auto)

20. CSS预处理器的好处

    > ## css代码更加整洁，更易维护，代码量更少
    >
    > - 修改很快，基础颜色使用变量，一处动牵全身
    > - 常用代码使用代码块，节省大量代码
    > - CSS嵌套减少了大量的重复选择器，避免一些低级错误
    > - 变量、混入大大提升了样式的复用性
    > - 额外的工具类似颜色函数(lighten/darken/transparentize等等)，mixins，loops，这些方法使css更像一个编程语言，让开发者能够有能力生成更加复杂的css样式。

21. Css预处理器的概念

    > ## CSS预处理器
    >
    > - 为css增加编程特性的扩展性语言，可以使用变量、见简单逻辑判断、函数等基本编程技巧
    > - CSS预处理器编译输出还是标准的CSS样式
    > - Less、Sass都是动态的样式语言，是CSS预处理器，CSS上的一种抽象层。他们是一种特殊的语法/语言而编译成CSS
    > - Less的变量符号是@，Sass变量符号是$
    >
    > ## 解决的问题
    >
    > - CSS语法不够强大，因为无法嵌套导致很多重复的选择器
    > - 没有变量和合理的样式复用机制，导致逻辑上相关的属性值只能以字面量的形式重复输出，难以维护
    >
    > ## 常用规范
    >
    > 变量、嵌套语法、混入、@import、运算、函数、继承等

22. 请描述下css盒模型基本概念

    > 1.margin、border、padding、content。在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容(content)、元素的内边距(padding)，元素的边框(border)、元素的外边距(margin)四个部分。这四个部分占有的空间中，有的部分可以显示其相应的内容，二有的部分只用来分割相邻的区域,这4个部分一起构成了css中元素的盒模型。
    >
    > > 2.分类：标准模型、IE模型
    > >
    > > - 标准模型IE模型的区别：计算高度和宽度的不同，怎么不同，高度宽度是怎么计算的？
    >
    > ```
    > 1.标准模型：
    >           div宽度=内容的宽度+border宽度+padding宽度//改变border宽度，div宽度就会变化
    >           box-sizing:content-box;//设置标准盒子模型
    >       2.怪异盒子模型||IE模型
    >           div宽度=内容的宽度+border宽度+padding宽度//改变border宽度，div宽度不会变化
    >           box-sizing：border-box//IE模型
    > ```

23. 响应式布局用到的技术有几种方式？

    > https://www.yuque.com/yanghui-xazj3/uu7edw/ukpngb

24. 移动端需要注意什么？

    > #### 1.添加禁止浏览器主动缩放功能
    >
    > 涉及到网页开发历史遗留问题，最开始的手机浏览器网页时直接访问电脑网页或访问专门为诺基亚手机开发的WAP页面，对于电脑网页由于手机分辨率太低，浏览器会使用缩放页面的方式来展示原页面，这个也是为什么在手机页面上直接使用document.documentElement.clientWidth获取到值为980，所以为了避免浏览器的自动缩放，需要在手机端
    >
    > ```
    > <meta name="viewport" content="width=device-width,user-scalable=no, initial-scale=1.0,minimum=1.0">
    > ```
    >
    > #### 2.移动端字体放大问题
    >
    > 当可视部分的宽度小于480px也就是iPhone横屏的时候，需要进行处理
    >
    > - 禁用html节点的字号自动调整。默认情况下，iPhone会将过小的字号放大，我们可以通过`-webkit-text-size-adjust`属性进行调整
    > - 将main-nav中的字号设置为90%
    >
    > ```
    > @media screen and (max-width:480px){
    >     html{
    >         -webkit-text-size-adjust:none
    >     }
    >     .main-nav a{
    >         font-size:90%;
    >         padding:10px 6px;
    >     }
    > }
    > ```
    >
    > #### 3.移动端1px的问题
    >
    > 在移动端web开发中，UI设计稿中设置边框为1px，前端在开发过程中如果出现：`border:1px`,测试会发现在某个机型上，1px会比较粗，即是经典的`移动端1px问题`。设备的物理像素(设备像素)和逻辑像素(css像素)可以使用`viewport+rem`或`transform:scale(0.5)`来实现。

25. 布局都有什么方式，float和position有什么区别？

    > #### 布局方式
    >
    > 1.静态块级 2.弹性布局(flex) 3.网络布局(grid) 4.自适应布局(根据当前访问设备进行多套样式来适配) 5.响应式布局(通过媒体查询进行适配，rem/em) 6.浮动布局(float) 7.定位布局(position)
    >
    > #### float和position有什么区别？
    >
    > - \>float：none left right inherit
    >
    > > 特性：
    > >
    > > - 浮动会脱离文档流，并且会随着分辨率和窗口尺寸的变化而变化
    > > - 浮动后面的元素如果是块级元素，会占据块级元素的文本位置，但会与块级元素背景和边框重叠
    > > - 多个浮动不会产生重叠现象
    > > - 会将块级元素和行内元素变为行内块元素
    > > - \>position：relative absolute fixed static 特性
    > > - relative和static不会脱离文档流
    > > - absolute和fixed会脱离文档流
    > > - absolute根据relative定位。fixed根据body定位
    > > - absolute和fixed会触发BFC
    > > - 定位的优先级高于浮动

26. CSS伪类和伪元素区别

    > - 1.伪类(pseudo-classes)
    >   - 其核心就是用来选择DOM树之外的信息，不能够被普通选择器选择的文档之外的元素，用来添加一些选择器的特殊效果
    >   - 比如 :hover :active :visited :first-child :focus :lang等
    >   - 由于状态的变化是非静态的，所以元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又失去这个样式
    >   - 由此看可以看出，它的功能和class有些类似，但是它是基于文档之外的抽象，所以叫伪类
    > - 2.伪元素(pseudo-elements)
    >   - DOM树没有定义的虚拟元素
    >   - 核心就是需要创建通常不存在于文档的元素
    >   - 比如::before ::after 选择的是元素指定内容，表示选择元素内容的之前的内容或之后内容
    >   - 伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于文档中，所以称为伪元素。用于将特殊的效果添加到某些选择器
    > - 3.两者区别
    > - 表示方法
    >   - css2中伪类、伪元素都是单冒号：表示
    >   - css2.1后规定伪类用单冒号表示，伪元素用双冒号::表示
    >   - 浏览器同样接受css2时代已经存在的伪元素(:before :after :first :line :first-letter等)的单冒号写法
    >   - css2之后所有新增的伪元素(::selection)，应该采用双冒号的写法
    >   - css3中，伪类与伪元素在语法上也有所区别，伪元素修改以::开头。浏览器对以:开头的伪元素也继续支持，但建议规范书写为::开头
    > - 定义不同
    >   - 伪类即假的类，可以添加类来达到效果
    >   - 伪元素即假元素，需要通过添加元素才能到达效果
    > - 总结
    >   - 伪类和伪元素都是用来表示文档树之外的"元素"
    >   - 伪类和伪元素分别用单冒号:和双冒号::来表示
    >   - 伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)
    >   - 是否需要添加元素才能达到效果，如果是则是伪元素，反之是伪类
    > - 4.相同之处
    >   - 伪类和伪元素都不会出现在源文件和DOM树中。也就是说在html源文件中是看不到伪类和伪元素的
    > - 不同之处
    >   - 伪类其实就是基于普通DOM元素而产生的不同状态，他是DOM元素的某一特征
    >   - 伪元素能够创建在DOM树中不存在的抽象对象，而且这些抽象对象是能够访问到的

27. 简单说下你理解的语义化，怎样来保证你写的符合语义化？HTML5语义化标签了解下？

    > 很多时候我们写HTML，为了方便都会直接使用div和span标签，在通过class来确定具体样式。网站哪一部分为标题，哪一部分为导航，哪一部分为头部和尾部，都只能通过class来进行确定。 但是class命名规范却又没有一套统一的标准，依次导致很多时候无法确定整体网站的结构 因此，在HTML5出现后，添加了关于页面布局结构的新标签。而在html书写过程中，根据不同的内容使用合适的标签进行开发，即为语义化。
    >
    > 在编程中，语义指的是一段代码的含义(这个HTML的元素有什么作用，扮演了什么样的角色)。HTML语义元素清楚地向浏览器和开发者描述其意义，例如form、table以及img等
    >
    > - 1.优点：对搜索引擎友好，有了良好的结构和语义，网页内容自然容易被搜索引擎抓取
    > - 2.HTML5新增语义元素 article aside details figcaption figure footer> header main mark nav section summary time
    > - 3.为什么要语义化？
    >
    > ```
    > 语义化的优势主要在于以下几点：
    >  其他开发者便于阅读代码，通过不同标签明白每个模块的作用和区别
    >  结构明确、语义清晰的页面能有更好的用户体验，在样式(css)没有加载前也有较为明确的结构，更如img这一类的，在图片无法加载的情况下有alt标签告知用户此处图片的具体内容；
    >  利于seo，语义化便于搜索引擎爬虫理解，和搜索引擎建立良好的沟通，能让爬虫爬取更多关键有效的信息
    >  方便其他设备阅读(如屏幕阅读器，盲人设备和移动设备等)
    > ```
    >
    > - 4.如何语义化？
    >
    >   ```
    >   一般的网站分为头部、导航、文章(或其他模块)、侧栏、底部，根据不同的部位，使用不同的标签进行书写。
    >   表示页面不同位置的标签：header、nav、article、section、footer、aside
    >   表示具体元素的作用或者意义的标签：a、abbr、address、audio、blockquote、caption、code、datalist、del、detail、ol、ul、figure、figuration、img、input、mark、p等
    >   - 尽可能少的使用无语义的标签div和span
    >   - 在语义不明显时，既可以使用div或者p时，尽量用p，因为p在默认情况下有上下间距，对兼容特殊终端有利；
    >   - 不要使用纯样式标签，如b、font、u等，改用css设置
    >   - 需要强调的文本，可以包含在strong或者em标签中(浏览器预设样式，能用css指定就不用他们)，strong默认样式是加粗(不要加b)，em是斜体(不用i)
    >   - 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，，单元格用td
    >   - 表单域要用fieldset标签包起来，并用legend标签说明表单的用途
    >   - 每个input标签对应的说明文件都需要使用label标签。并且通过input设置为id属性，在label标签中设置for=someld来让说明文本和相对应的input关联起来
    >   ```
    >
    > - 5.注意点：
    >
    >   ```ht
    >   em、strong、dfn、code、samp、kbd、var、cite等，虽然这些标签定义的文本大多会呈现处特殊的样式，但实际上，这些标签都拥有确切的语义 我们并不反对使用它们，但是如果您只是为了达到某种视觉效果而使用这些标签的话，我们建议您可以使用样式表，那么做会达到更加丰富的效果。
    >   ```
    >
    >   

28. 在css中link和@import的区别是什么？

    > - 1.从属关系区别：
    >
    >   > link是属于html标签，而@import是css提供的
    >
    > - 2.加载顺序区别：
    >
    >   > 页面被加载时，link会同时加载，而@import引用的css会等到页面被加载完再加载
    >
    > - 3.兼容性区别：
    >
    >   > import只在IE5以上才能识别，而link是html标签，无兼容问题
    >
    > - 4.dom可操作性的区别：
    >
    >   > 可以通过js操作dom，插入link标签来改变样式；由于dom方法是基于文档的，无法使用@import的方式插入样式
    >
    > - 5.权重区别：
    >
    >   > 在.css文件用import引入时，如果已经存在相同样式，@import引入的这个样式将被该css文件本身的样式层叠掉，表现出link方式的样式权重高于@import的权重这样的直观效果
    >
    > > 简而言之：link和@import，谁写在后面，谁的样式就被应用，后面的样式覆盖前面的样式

