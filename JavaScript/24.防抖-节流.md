# 防抖（debounce）

原理：在事件被触发n秒之后，再执行回调函数。如果在这段时间内，事件又被触发，则重新计时。

```js
// immediate参数为true，立即执行
function debounce(func, wait, immediate) {
    let timeout;
    let complete = function() {
        let context = this;
        let args = arguments;
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            let callNow = !timeout;
            timeout = setTimeout(function() {
                timeout = null;
            }, wait);
            if (callNow) return func.apply(context, args);
        } else {
            timeout = setTimeout(function() {
                // 使得context指向container容器， args是把事件对象传递过去
                return func.apply(context, args);
            }, wait);
        }
        
    }
    // 取消防抖
    complete.cancel = function() {
        clearTimeout(timeout);
        timeout = null;
    }
    return complete;
}

function doSomeThing(e) {
    console.log(this, e)
}

container.onmousemove = debounce(doSomeThing, 300, false)
```

应用场景：

- 按钮提交，只执行最后一次的提交，防止重复提交
- 搜索框搜索，只搜索最后一次的输入
- 判断scroll是否滚动到底部



# 节流

原理：持续触发事件，每隔一段时间，触发一次事件

```js
// 定时器版本   开始不触发，最后一次触发
function throttle(func, wait) {
    let context, args, timeout;
    return function() {
        context = this;
        args = arguments;
        if (!timeout) {
            timeout = setTimeout(function() {
                func.apply(context, args);
                timeout = null;
            }, wait);
        }
    }
}
```

```js
// 时间戳版本   开始触发，最后不触发
function throttle(func, wait) {
    let context, args, old;
    return function() {
        context = this;
        args = arguments;
        let now = new Date().valueOf();
        if (now - old > wait) {
            func.apply(context, args);
            old = now;
        }
    }
}
```

```js
// 二者结合，新增第三个参数，控制首尾执行情况
// options: {leading: true, trailing: true}
function throttle(func, wait, options = {}) {
    let context, old, args, timeout;
    return function() {
        context = this;
        args = arguments;
        now = new Date().valueOf();
        if (options.leading === false) { // 第一次不触发
            old = now;
        }
        if (now - old > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            func.apply(context, args);
            old = now;
        }
        if (!timeout && options.trailing) { // 控制最后一次触发
            timeout = setTimeout(function() {
                func.apply(context, args);
                old = new Date().valueOf();
                timeout = null;
            }, wait);
        }
    }
}
```

应用场景：

- scroll滚动
- 计算鼠标移动的距离
- 射击类游戏
