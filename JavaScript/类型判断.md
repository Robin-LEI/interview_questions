typeof 判断基本数据类型

typeof可以判断除了null以外的原始数据类型

typeof null 是object

typeof [] 是object

缺点就是对于引用数据类型判断不准确



instanceof 判断对象的具体类型

A instanceof B

A是B的实例，B在A的原型链上

[] instanceof Object // true

缺点是不够精确，因为对象的原型是可以随意修改的，另外它也不能检测基础数据类型

instanceof 如何检测基础数据类型？？

我们可以借助于Symbol.hasInstance元编程能力

```js
class PrimitiveNumber {
    static [Symbol.hasInstance] = x => typeof x === 'number'
}
123 instanceof PrimitiveNumebr // true
```



constructor

null/undefined没有该方法

```js
// 加上()，是因为()可以把数值转换为对象
(1).constructor // f Number() {[native code]}
// 或者
1..constructor
```

除了null和undefined，constructor可以检测出基础数据类型和原始类型

缺点是因为constructor是可以随意修改的，所以此方法检测是不安全的



Object.prototype.toString.call

日常使用最多



封装一个检测数据类型的方法

```js
function getType(obj) {
    let type = typeof obj;
    if (type !== 'object') {
        return type;
    }
    return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1').toLowerCase();
}

console.log(getType(1));
console.log(getType('1'));
console.log(getType(true));
console.log(getType(/\d/g));
console.log(getType({}));
console.log(getType(new Date()));
console.log(getType(function() {}));
console.log(getType(Symbol('1')));
console.log(getType([]));
console.log(getType(null));
console.log(getType(undefined));
```



函数是特殊的对象，特殊在函数可以执行。

数组是特殊的对象，特殊在数值下标、内部数据是有序的。

