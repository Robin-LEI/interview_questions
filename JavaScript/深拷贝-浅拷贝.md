# 浅拷贝

## 如果是一个基础数据类型，拷贝的是值，如果是引用数据类型，拷贝的是引用地址

1. 直接赋值
2. Object.assign(obj) // Object.assign(target, source)
3. for...in循环，直接赋值



# 深拷贝

## 将对象从内存中完整的拷贝一份出来，并且在堆中开辟一个新的区域存放这个对象，保证修改原来的对象不会影响新的对象

1. JSON.parse(JSON.stringify())

   - 源对象中有属性值为函数的属性，拷贝后会丢失
   - 如果拷贝的属性值是一个 new Date 时间对象，拷贝后变成字符串
   - 如果待拷贝的属性中有正则对象、Error，拷贝后变成空对象

2. jQuery的 $.extend()

   ```js
   <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"></script>
   <script>
       var obj = {
           name: '小明',
           func: () => {},
           date: new Date(),
           reg: new RegExp(),
           error: new Error()
       }
       var target = {}
       // 默认第一个参数是false，表示浅拷贝
       // 第二个参数表示目标对象，后面的参数表示待拷贝对象
       var copy = $.extend(true, target, obj, {name: 'xxxx'})
   	console.log(copy, obj);
   </script>
   ```

   

   

3. 手写js深拷贝

   ```js
   function deepClone(obj) {
       if (typeof obj !== 'object' || obj === null) return obj;
       if (obj instanceof Date) reutrn new Date(obj);
       if (obj instanceof RegExp) reutrn new RegExp(obj);
       if (obj instanceof Error) reutrn new Error(obj);
       
       let result;
       
       if (obj instanceof Array) {
           result = [];
       } else {
           result = {};
       }
       
       for (let key in obj) {
           if (Object.prototype.hasOwnProperty.call(obj, key)) {
               result[key] = deepClone(obj);
           }
       }
       
       return result;
   }
   ```
   
   