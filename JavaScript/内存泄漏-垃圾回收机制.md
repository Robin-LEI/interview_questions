为什么需要关注内存？

内存占用过多，引起客户端卡顿，甚至页面没有响应。

Node使用的也是V8引擎。



js使用自动内存管理，被称为“垃圾回收机制”。

优点：简化开发、节省代码

缺点：无法完整的掌握内存的分配和回收的过程。



js是异步单线程

新生代和老生代算法不一样，老生代是标记清除整理。



V8内存限制

在64位操作系统可以使用1.4G

32位可以使用0.7G

为什么要限制？

垃圾回收的时候，代码运行会暂停，垃圾回收机制---运行线程，回收一次1.5G堆内存，需要50ms/1s以上



V8基于分代的回收机制

不同代机制不一样。分为新生代和老生代。 

新生代分为两个区from和to，大小是一样的，一个使用，一个空闲。



垃圾回收机制每回收一次，from和to会调换一次。

经过多次垃圾回收机制还存在的会被移动到老生代。也就是from和to互换了5次还存在的会被移入到老生代。



老生代空间大，大部分是活着的对象，GC耗时比较长，在GC期间无法响应，V8有一个优化方案，增量处理把一个大的暂停换成多个小的暂停。

标记清除：先标记在清理，对死的和活的分别标记。缺点是死的清除之后，所在位置不能用，会形成碎片。

标记整理：活的左移，死的右移，特点是效率比较慢，好处是不会形成碎片。

增量标记：一次干的活分多次干，这样每次耗的时间就少



# 哪些操作会造成内存泄漏

1. 闭包

2. 定时器，设置 this.timers = null; 并不能清除掉定时器，得使用 clearTimeout或者clearInterval

3. 对DOM的引用，虽然在其他的地方删除了，但是在对象上还存在对dom的引用

   ```js
   let ele = {
       btn: document.getElementById('btn')
   }
   function doSomething() {
       ele.btn.click()
   }
   function remove() {
       document.body.removeChild(document.getElementById('btn'))
   }
   // 虽然在dom树中移除了btn，但是此时全局变量ele还是保留了对btn的引用，btn还是存在于内存中，不能被GC回收
   ```

   

4. 意外的全局变量