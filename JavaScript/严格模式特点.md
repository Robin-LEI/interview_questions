# 严格模式特点

**使用严格模式的好处是可以提前发现代码中的错误**

1. 全局作用域中的this依然指向window，但是全局作用域中的函数中this指向undefined

   ```js
   'use strict';
   function func() {
       console.log(this) // undefined
   }
   console.log(this) // window
   func()
   ```

   

2. 不允许创建没有声明符号的变量

   ```js
   'use strict';
   a = 1; // 报错
   ```

   

3. 不允许对变量使用delete操作符

   ```js
   'use strict'
   var color = 'red'
   delete color // 报错
   ```

   

4. 严格模式下不能使用关键字或保留字命名变量

   ```js
   'use strict'
   var package|implements|yield|interface|static = 1 // 报错
   ```

   

5. 在严格模式下，对于对象属性为configurable: false时使用delete删除该属性报错

   ```js
   var obj = {}
   Object.defineProperty(obj, 'name', {
       value: '李四',
       configurable: false
   })
   delete obj.name // 报错
   ```

   

6. 对于一个不可扩展属性的对象，给其添加新属性会报错，在非严格模式下，不会报错，但是也不会生效

   ```js
   'use strict'
   var obj = {}
   // 设置对象为不可扩展
   Object.preventExtensions(obj)
   obj.name = '李四' // 报错
   ```

   

7. 函数的形参问题，在严格模式下，函数的形参名不能重复，重复会报错，但是在非严格模式下，如果形参名重复，第二个会覆盖第一个

8. 在严格模式下，修改函数的形参值，不会映射到arguments对象上，但是在非严格模式下，会映射

   ```js
   'use strict'
   function add(num, age) {
       num = 111
       age = 222
       console.log(num, age, arguments) // 111 222 [1,2]
   }
   add(1,2)
   ```

   

9. 严格模式下，对函数名也做了限制，不允许使用关键字或保留字作为函数名

   ```js
   'use strict'
   function interface() {} // 报错
   ```

   

10. 严格模式下，eval不会在上下文中创建变量或者函数

    ```js
    'use strict'
    function add() {
        eval('var a = 1') // 报错
    }
    add()
    ```

    

11. 严格模式下，没有with语法

12. 严格模式下，不能使用八进制，会报错

    ```js
    'use strict'
    var value = 010 // 报错
    
    // 严格模式下，使用parseInt解析八进制字符串的时候，会把他当做十进制去解析
    ```

    

13. 



# 严格模式this的指向问题