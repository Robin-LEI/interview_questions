模块化可以用来解耦功能，解决全局变量污染，代码冗余，变量名冲突等代码维护的问题。



发展历程：

最开始的没有模块化--> IIFE的立即执行函数模块化-->commonjs--> AMD--> CMD --> Es6



各种模块化的特点

commonjs：nodejs采用的一种模块同步加载规范，一个文件就是一个模块。使用的时候使用require引入即可。

但是commonjs规范并不适合在客户端使用，因为假如在浏览器端使用commonjs规范，在使用require引入模块的时候，受制于网络情况，浏览器可能会出现假死状态，用户要等待很长时间，影响用户体验。

但是在服务端不存在这个假死问题，因为所以的模块都存在本地硬盘，可以同步加载完成。

因此诞生了AMD模块异步加载规范。



AMD：

requireJS采用的是AMD规范，使用的时候先定义所有依赖，然后再模块加载完成后的回调函数中执行。

缺点是属于**依赖前置**，需要先加载所有的依赖，不可以像commonjs规范那样，使用的时候才require。

所以出现了CMD规范。



CMD：

seajs采用的是CMD规范。

定义的时候不需要先罗列所有的依赖，采用**依赖就近**原则，实现了commonjs风格的代码。



ES6模块化通过import导入、export导出的形式。比commonjs效率高，可以实现按需加载，适合服务端和客户端。