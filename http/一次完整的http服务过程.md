 **V1.0**

1. 根据用户输入的url解析出ip
2. 根据ip地址，客户端和服务器端建立tcp连接
3. 客户端发起http请求
4. 服务端返回html给浏览器
5. 浏览器解析html资源，包好一些js、css、img等
6. 浏览器渲染html到页面
7. 关闭tcp连接



**V2.0**

1. 根据用户输入的url，使用DNS解析出对应的ip，DNS域名解析采用的是递归查询，先去找缓存，找不到去找根域名服务器，找不到再去找下一级，直到找到之后返回给浏览器
2. 拿到ip之后，建立tcp连接
3. 发送http请求，http协议要基于tcp协议，这样不用担心数据传输时遇到的各种问题，因为tcp是一个可靠的传输协议，当发生错误的时候，会重传
4. 服务器响应html给浏览器
5. 浏览器解析html构成DOM树，解析css构建css 渲染树
6. 浏览器边解析、边渲染页面
7. 关闭tcp连接



**V3.0**

DNS域名解析

查找过程：浏览器自身域名缓存区查找、操作系统的域名缓存查找、hosts查找【可以人为干预介入】、域名服务器查找【这个过程是一个递归查询的过程，找到找到，返回对应的ip给浏览器】



浏览器解析html：根据dom元素构建DOM树，根据css构建css渲染树，二者结合生成html渲染树，然后计算元素的位置和尺寸，最终渲染到页面上。

当用户操作界面的时候，会触发重排和重绘。首次渲染的时候，必然会经过重排和重绘。、



关闭tcp连接

一般情况下，服务器向浏览器发送了请求数据之后，服务器会关闭tcp连接，通过在头中加入信息 Connection: keep-alive，tcp连接在发送之后仍然保持连接状态，这样下次浏览器在向服务器发送http请求不需要再次建立tcp连接，提升性能，节约网络带宽。



重排重绘

重排：渲染树上的元素节点的位置、尺寸或者部分属性改变了，导致浏览器重新渲染部分或全部文档的过程。

会导致重排的操作：

1. 元素的位置或尺寸
2. 页面首次渲染
3. 浏览器窗口发生变化
4. 元素的内容发生变化
5. 增加或删除dom
6. 元素字体大小变了
7. 会导致回流的属性和方法：clientWidth、offsetWidth等



重绘：页面中的元素的样式发生了改变（color、background-color、visibility等），但是不影响元素在文档流中的位置，这个时候浏览器只需要重新绘制它的新样式即可。



那么如何减少重排和重绘的次数呢？

1. 避免频繁操作样式，最好一次性重写style属性，或者将样式定义为class一次性更改class属性
2. 避免频繁操作dom，创建一个documentFragment，在她上面应用所有的dom，最好一次性的将它添加到文档中
3. 也可以先把元素设置为display: none；操作结束之后再把它显示出来，因为在display：none的属性上操作dom不会引起回流和重绘。
4. 避免频繁读取会引起回流/重绘的属性，可以用变量缓存起来



tcp三次握手四次挥手

tcp连接的时候是三次握手，关闭tcp的时候是四次挥手。

客户端要想与服务器建立连接的时候，需要先发出一个SYN包，询问服务器能否与你建立连接，如果服务器端同意，则回复一个SYN+ACK包，客户端收到之后，回复一个 ACK包，连接建立。

为什么是三次握手，而不是两次呢？

为了防止已经失效的请求报文，突然又传到服务器引起错误，假设采用两次握手建立连接，客户端向服务端发送了一个SYN包来请求建立连接，因为某些原因导致SYN包并没有到达服务器，在中间某个网络节点产生了滞留，为了建立连接，客户端会重发SYN包，这次的数据包正常送达，服务端回复SYN+ACK之后建立了连接，但是第一包数据阻塞的网络节点，突然恢复，第一包SYN包又送达服务端，这时服务端会误认为是客户端又发起了一个新的连接，从而在两次握手之后，进入等待数据状态，服务端认为是两个连接，而客户端认为是一个连接，造成了状态不一致，如果在三次握手的情况下，服务端收不到最后的ACK包，自然不会认为连接建立成功，所以三次握手本质上来说就是为了解决网络信道不可靠的问题，为了能够在不可靠的信道上，建立可靠的连接。



tcp传输的时候，一包数据可能被分成多包数据传输，如何处理丢包的问题？如何处理乱序问题？

tcp协议为每一个连接，建立了一个发送缓冲区，从建立连接后的第一个字节序列的序列号为0，依次递增1，发送数据时，从缓冲区取一部分数据组成发送报文，在tcp协议头中，会附带序列号和长度，接收端在收到数据时候，需要回复确认报文，确认报文中的ACK等于接受序列号+长度，也就是下一包数据需要发送的起始序列号。如果中间丢了某些数据包，接收端可以要求发送端重传，如ACK=100，服务端从100开始传。



四次挥手：

处于连接状态的客户端和服务端都可以主动发出请求断开连接，此时需要四次挥手来进行连接关闭，假设客户端主动发起关闭连接请求，他需要向服务端发送一包FIN包，表示要关闭连接，自己进入终止等待1状态，这是第一次挥手，服务端收到FIN包，回复一包ACK包，表示自己进入了关闭等待状态，客户端进入终止等待2状态，这是第二次挥手，服务端此时还可以发送未发送的数据，客户端也还可以接收数据，待服务端发送完数据之后，发送最后一包FIN包，进入最后确认状态，这是第三次挥手，客户端收到之后回复ACK包，进入超时等待状态，经过超时时间之后关闭连接，而服务端收到ACK包之后，立即关闭连接，这是第四次挥手，为什么客户端需要超时等待时间？这是为了保证对方已经收到ACK包，因为假设客户端发送最后一包ACK包后就释放了连接，一旦ACK包在网络中丢失，服务端将一直停留在最后的确认状态，如果客户端发送最后一包ACK后，等待一段时间，这时服务端因为没有收到ACK包，会重发FIN包，客户端会响应这个FIN包，重发ACK包并刷新超时时间，这么做的目的是为了在不可靠的网络信道中，保证可靠的连接断开。



udp是非连接的，发送数据的时候，只需要把数据包从网卡中发送出去即可，数据包之间没有状态上的联系，所以udp的性能损耗少，资源占用少，不能保证丢包，稳定性不高。



tcp：传输文件、浏览网页、发送邮件

udp：语音、视频