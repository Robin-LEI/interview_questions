更新流程

对象更新流程

vm.name = 'xxx'



一个属性对应一个 dep，一个dep对应多个 watcher，一个watcher可以对应多个dep。

dep是用来收集渲染逻辑的（收集watcher的）。

每个组件都有一个watcher，称之为渲染watcher。

只有在视图中使用的数据更新才需要更新视图。



在调用 Object.defineProperty 之前 new Dep，给每个属性都增加一个dep。 



只有在渲染的时候，才会进行依赖收集，因为渲染完毕后，就会将标识清空了（Dep.target = null）。



多个组件就会有多个watcher。



页面初次渲染的时候，会将 Watcher 放到 Dep.target 上。渲染完毕将 Dep.target = null；



set的时候，让dep中存储的watcher 调用 update方法依次执行。



vue里面用到了观察者模式，默认组件渲染的时候，会创建一个watcher，并且会渲染视图，当渲染视图的时候，会取data中的数据，会走每个属性的get方法，就让这个属性的dep记住watcher，同时让watcher也记住dep，dep和watcher是多对多的关系，因为一个属性可能对应多个视图，一个视图也可能对应多个数据，如果数据发生变化，会通知对应属性的dep，依次通知存放的watcher去更新。



调用render方法，就会立即取值，走到 get方法

，和watcher关联起来。



触发set，会通知当前属性收集的watcher依次执行。



组件挂载，创建 渲染Watcher。



vue为什么要用·异步更新？

```js
vm.name = 'zf'
vm.name = 'jw'
vm.name = 'zf'
vm.name = 'jw'
// 以上操作会触发 四次 update
```

nextTick

每次更新数据，都会同步调用 update方法，

我们可以将更新的逻辑缓存起来，等到同步更新数据的逻辑执行完毕后，依次调用（去重）。

```js
```



vue3里面的nextTick就是promise，vue2做了一些兼容处理。

Promise.resolve().then(fn)



vm.name = 'jw'

console.log(vm.$el.innerHTML) // 老的，因为是异步更新的数据



===============

vue中数组依赖收集

给数组也加了一个dep属性，

[].\__ob__.dep

不管数组还是对象，取值都会触发 get

数组和对象本身也会进行依赖收集

属性是一个数组的话，会递归做一个依赖收集。

1. 默认vue在初始化的时候，会对对象每一个属性进行劫持，增加dep属性，当取值的时候会做依赖收集
2. 默认还会对数组



如果给一个对象增加一个不存在的属性，也能更新视图。

